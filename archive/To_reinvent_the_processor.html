<!DOCTYPE html><html><head><title>To reinvent the processor</title><meta name="author" content="Veedrac"></head><body><div><div class="l"><div class="l"><header class="pw-post-byline-header fq fr fs ft fu fv fw fx fy fz l"></header><section><div><div class="ia ib ic id ie"><p id="f8ec" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><em class="kc">This is a very long, very dense, and very technical foray into CPU architecture. I&#x2019;ve tried to make this approachable to enthusiast non-professionals, but if you don&#x2019;t know roughly how CPUs work, you will struggle.</em></p><h2 id="0a80" class="kd">Contents</h2><pre class="lb lc ld le fz lf bt lg"></pre><p id="98ec" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">I&#x2019;m tired of the dominance of the out-of-order processor. They are large and wasteful, the ever-popular x86 is especially poor, and they are hard to understand. Their voodoo would be more appreciated if they pushed better at the limits of computation, but it&#x2019;s obvious that the problems people solve have a latent inaccessible parallelism far in excess of what an out-of-order core can extract. The future of computing should surely not rest on terawatts of power burnt to pretend a processor is simpler than it is.</p><p id="a4a3" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">There is some hope in the ideas of upstarts, like Mill Computing and Tachyum, as well as research ideas like CG-OoO. I don&#x2019;t know if they will ever find success. I wouldn&#x2019;t bet on it. Heck, the Mill might never even get far enough to have the opportunity to fail. Yet I find them exciting, and much of the offhand &#x201C;sounds like Itanium&#x201D; naysay is uninteresting.</p><p id="cf92" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This article focuses on architectures in proportion to how much creative, interesting work they&#x2019;ve shown in public. This means much of this article comments on the Mill architecture, there is a healthy amount on CG-OoO, and the Tachyum is mentioned only in passing. There are more I could have discussed, like TRIPS (an older dataflow architecture), Denver (NVIDIA&#x2019;s newish ARM architecture using binary translation) or VISC (Soft Machine&#x2019;s &#x2018;threadlet&#x2019; architecture that got killed by Intel), but I chose to look at the architectures that I consider most promising for general-purpose workloads.</p><p id="a416" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Along with details and comments on these technologies, I have tried to supplement the article with my own untested ideas. These are formulated to get people to focus more directly on the underlying limits of the system, and anyone should feel free to take or extend those ideas if they can make something of them. Not all of my ideas are entirely unique, but I suspect some of them are new.</p><h2 id="9baf" class="kd">The fundamental work of an instruction</h2><p id="9e53" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">A typical instruction in a typical instruction set performs something like the following:</p><ul class><li id="7407" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb mc md me mf gi">Read the operands from the global register file.</li><li id="ec44" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Perform the operation.</li><li id="4d3a" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Write the output to the global register file.</li></ul><p id="d1a2" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This looks inoffensive until you start looking at the critical path between instructions, especially with a high level of parallelism and where the operation is something cheap, like addition.</p><ul class><li id="5b4f" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb mc md me mf gi">Read 16 operands from the global register file simultaneously, at arbitrary locations.</li><li id="49a3" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Perform 8 simultaneous operations.</li><li id="8c44" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Write the 8 results to the global register file simultaneously, at arbitrary locations.</li><li id="638e" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Read 16 new operands from the global register file simultaneously, and subset of which may be any combination of the just-written results.</li><li id="5e55" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Perform 8 simultaneous operations.</li><li id="733d" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">&#x2026;</li></ul><p id="601c" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">It is difficult enough to figure out how to build a register file that can support this throughput on a cycle-by-cycle basis. It is another to use this as a primary method for routing data between functional units. You can only really mitigate the former issue, but the latter has a standard and inoffensive solution: operand forwarding.</p><figure class="lb lc ld le fz mm fn fo paragraph-image"><figcaption class="mt bm fp fn fo mu mv bn b bo bp co">If the functional units need their output again at a low latency, they route through the highlighted path. Most such instructions still need to be written to the register file unless they are immediately overwritten, in case another instruction later on requires them.</figcaption></figure><p id="7067" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This approach helps the situation, but scaling can still be a challenge. A Skylake CPU has <em class="kc">348 physical registers</em> per core, split over two different register files. In contrast, there are 8 execution pipelines, only half of which have general ALUs, so the forwarding path is much smaller.</p><h2 id="0afa" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">Coarse-Grained Out-of-Order (CG-OoO)</h2><p id="ca80" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Modern cores have enough transistors to build these huge register files &#x2014; a modern smartphone has billions &#x2014; but they add latency, long wires and communication costs. The cost also scales with the increasing number of read and write ports. Even more importantly, out-of-order hardware struggles to scale because the core has to keep track of dependencies globally between a vast number of buffered instructions.</p><p id="3a4c" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">CG-OoO is a design intended to break this set of global dependencies whilst still allowing for long-ranged out-of-order execution. The key observation allowing this is that it seems possible to handle dependencies hierarchically, and circumvent the imperfections in the hierarchical approach &#x2014; inefficient allocation of resources &#x2014; by overprovisioning the execution resources.</p><figure class="lb lc ld le fz mm fn fo paragraph-image"><figcaption class="mt bm fp fn fo mu mv bn b bo bp co">A simplified version of Fig 1. from the CG-OoO paper. Block Windows (BW) feed instructions into execution clusters, each with a number of <em class="nk">Execution Units (EU)</em>. A BW contains a small, unshared Local Register File (LRF) and a subset of a shared Global Register File (GRF).</figcaption></figure><p id="a374" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Each Block Window (BW) in the diagram above is responsible for the execution of a single basic block, a region of code without internal control flow that generally averages 5&#x2013;20 instructions long. Each Block Window contains two small register files. One is a low-throughput Local Register File (LRF), which is only visible to the executing basic block, and another is a segment of a larger Global Register File (GRF), which communicates globally to all other Block Windows.</p><p id="fcec" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The Local Register File is used for approximately 1 in 3 operands and supports a BW with minimal amortized throughput, at only 2 reads and 2 writes per cycle. The LRF is short, but generously provisioned relative to the length of the basic block, 20 entries long for their models, avoiding hazards without renaming. According to the authors, this makes the LRF a factor of 25 cheaper per access than a 256-long heavily-multiported register file.</p><p id="883e" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The Global Register File is shared and requires renaming &#x2014; that is, the production of a mapping from the source register file indices to GRF indices such that all semanic writes are to different GRF indices, with reuse only after a later write to the source register file index is marked as non-speculative. Renaming maps writes by a Block Window to the local GRF segment, so only register reads are global.</p><p id="ac90" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Out-of-order execution also introduces costs for instruction issue and wakeup: In a fully out-of-order processor, any write to the LRF could make any locally-queued instruction ready to issue, and any write the the GRF could make any instruction ready to issue from any BW. Therefore, CG-OoO performs only a small amount of out-of-order execution, hierarchically. Within each BW, only from the first three or so unissued instructions are candidates for dispatch. Distant parallelism is only extracted by parallel execution of BWs.</p><p id="e66a" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The corresponding cost reductions are worth listing explicitly.</p><ol class><li id="388d" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb nl md me mf gi">Local instruction reordering is cheap, requiring hazard checking hardware and wakeup only over about three to five local instructions.</li><li id="6ee7" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Global wakeup affects only those instructions that take global registers and are in the small set of candidate operations for each BW.</li><li id="e7bd" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Stalled instructions are sufficiently limited in number that they can cache operands inside the issue hardware. They will then be able to read any missing operands in later cycles from the bypass, so only freshly queued instructions ever perform explicit GRF reads.</li><li id="5206" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Each GRF segment requires few ports, since GRF reads will be mostly distributed between segments.</li></ol><h2 id="126a" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">The Mill</h2><p id="8e9d" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Whereas CG-OoO allows for significant aggregate throughput at the expense of limiting local throughput to a single instruction per cycle amortized, and underperforms when local ILP is unusually large, the Mill first attempts to obliterate local throughput limits and uses secondary methods to extract nonlocal parallelism.</p><p id="5fb1" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">You can get most of the motivation needed to invent the Mill&#x2019;s belt by noticing how much more headroom operand forwarding has than large global register files, primarily because of the comparatively miniscule number of sources. If the principle operations in a CPU should be those that can be done fast and cheap, the bypass should be the primary source of data movement and multiported register files should only be involved when necessary for long-term storage.</p><p id="1720" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">We can prioritize the use of the bypass by making operands more available from it using a small amount of buffering of the outputs at the end of each pipeline. In synergy, we can make register file operations opt-in; the Mill calls reads and writes to their register file substitute <em class="kc">fill</em> and <em class="kc">spill</em>.</p><figure class="lb lc ld le fz mm fn fo paragraph-image"><figcaption class="mt bm fp fn fo mu mv bn b bo bp co">The Mill is different yet; their register file is replaced with a &#x2018;scratchpad&#x2019;, which is allocated per frame and accessed with byte offsets. It has a 3-cycle spill-to-fill latency, and their Silver core can handle only 4 spills and fills per cycle in total &#x2014; entirely insufficient for a similar-width out-of-order, but easily in excess here.</figcaption></figure><p id="452d" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">With this it&#x2019;s easy to see that this gives a greater opportunity for the hardware to scale, and detaches register pressure from overall throughput, this raises a few questions.</p><ol class><li id="b86a" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb nl md me mf gi">How do you build a bypass that scales with the increased buffering in the system?</li><li id="71de" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">How do you avoid this impacting the critical path latency, relative to the smaller, faster bypass in a standard processor?</li><li id="67eb" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">How much buffering is needed, and how do you prevent this becoming a bottleneck?</li><li id="a6c5" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi"><strong class="jg ii">How does the program interface with the hardware?</strong></li></ol><p id="4dcf" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The Mill has a straightforward approach to this challenge. A crossbar, a piece of hardware that connects N sources with M sinks, easily scales to the sizes involved here. Unfortunately, larger crossbars have more latency than the original bypass, slowing clock speeds. A solution to this issue is possible by building a fast path into the crossbar.</p><p id="ac1e" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Latency-1 instructions immediately exit into a designated latency-1 buffer. Higher latency instructions enter corresponding higher-numbered buffers, and latency-1 instructions also migrate to higher-numbered buffers after their first cycle. These latency-1 buffers are small in number and latency-critical, and enter the crossbar fast-path. Instructions with higher latency are less impacted by increased routing delay and often don&#x2019;t end cleanly on a cycle boundary, so can start their routing earlier in the cycle using the slow-path crossbar.</p><p id="666d" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The amount of buffering needed is of major concern. Luckily, many values are completely temporary, and thus proper scheduling does not need much buffering for these at all. Further, the register file or scratchpad easily handles many longer-lived values. It would seem that few cycles of buffer may well suffice, to cover those outputs that live only just short enough that they cannot be migrated without overhead to the register file or scratchpad.</p><p id="92a9" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The Mill resolves some further rough-edges. Operations are migrated between buffers, and automatically spilled to a side buffer, to extend the life of operands in the case of skew pipeline usage. This automated data movement is made practical in part because these pathological cases are those with low throughput, at least in the Mill&#x2019;s semantic model. When every pipeline is producing values every cycle, operands fall off the belt very fast. The only time operands last a long time on the belt (without being explicitly recovered, and ignoring function calls) is when the belt is moving slowly.</p><p id="a74a" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The last question about the program-facing interface to the hardware is left open, and touched on in later sections.</p><h2 id="4524" class="kd">Dependencies, not order</h2><p id="e527" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Exploring the CG-OoO&#x2019;s approach shed some light on the trade-offs required in the construction of an out-of-order processor. However, the previous discussion intentionally did not clarify whether the Mill&#x2019;s approach was for an in-order or out-of-order core. In fact, very little of the Mill&#x2019;s approach seems to directly improve the cost-benefit ratio of out-of-order hardware, as it would seem all of the complex wakeup logic would still have to exist.</p><p id="1e61" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">One might be tempted to consider a CG-OoO-Mill hybrid, if just for perspective. However, it is difficult to imagine; the belt is optimized for throughput on values with short lifetimes, so regardless of whether the core supports out-of-order execution, we must confront the challenge of extracting static parallelism directly.</p><p id="bdda" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Mill Computing claims that in-order computing is possible to do fast, and they give quite a few tools to get there. Before analyzing these, a causal understanding of the specific benefits out-of-order approach is warranted. The following shortlist, though brief, should be nearly exhaustive.</p><ol class><li id="1f64" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb nl md me mf gi">Out-of-order hardware handles false dependencies, such as through condition codes and register hazards.</li><li id="0b9c" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Out-of-order hardware allows near-optimal scheduling around control flow.</li><li id="88db" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Out-of-order hardware efficiently schedules in the context of variable-latency instructions, particularly for memory access.</li></ol><h2 id="ccd6" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">1. False dependencies</h2><p id="fa32" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Exceptions on integer division by zero and condition codes both create incidental dependencies: exceptions prevent the compiler from reordering instructions outside of loops and ifs, or across globally-visible memory writes, and condition codes make hardware speculation more difficult. The solution to both issues is to put these conditions into software, with division by zero resulting in a register value of some sort, and conditions being handled with booleans and comparisons. This solution is so noncontroversial that even the conservative RISC-V architecture takes this approach. Another issue in this category is exceptions on a failed memory load, but memory is better delegated to its own section due to its complexity.</p><p id="8cee" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Register hazards are an unavoidable consequence of using a limited number of names to refer to an unbounded number of source-level values. There are really only two issues from these hazards:</p><ol class><li id="ab26" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb nl md me mf gi">Register hazards force storage elements to be used in program order, impeding dynamic reordering without renaming.</li><li id="0e75" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Register name limits represent an upper bound on data that can be stored in the primary storage medium without renaming.</li></ol><p id="c362" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The Mill is affected by both issues, since the hardware state of the belt varies depending on how the current control block was reached. The Mill uses renaming to solve the first of these issues, and uses a sizeable scratchpad without renaming for the second. Rename hardware is cheap enough that this is not an unacceptable compromise, and the Mill&#x2019;s rename tables are smaller than a comparable out-of-order processor&#x2019;s regardless.</p><figure class="lb lc ld le fz mm fn fo paragraph-image"><figcaption class="mt bm fp fn fo mu mv bn b bo bp co">Modified Fig 15 (b). from the CG-OoO paper. The energy cost of rename dominates the rest of decode in their modelled processors, with the stage taking 9%, 14% and 0.2% of total execution power for each processor, respectively.</figcaption></figure><p id="7207" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Whilst rename is an unavoidable cost of this sort of runtime-execution mismatch, it&#x2019;s far from obvious that full, unstructured rename is the best we can do. In fact, it seems a variant of the CG-OoO architecture might allow for completely removing the rename stage, and the associated ad-hoc global communication.</p><p id="aba8" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">In an out-of-order CPU, each instruction has its own view of the logical global register file &#x2014; the program-visible registers at that point in the execution &#x2014; , which are mapped onto some subset of the physical register file. Because a potentially unique view must exist for all of 200+ instructions in the reorder buffer, it&#x2019;s important that this state is shared. This is what rename is good at.</p><p id="c23d" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">In the CG-OoO architecture, each Block Window, not each instruction, has its own view of the logical global register file. Each Block Window writes to any given register at most once, and each basic block has a header that declares which registers will be written to. This makes sharing registers less necessary.</p><p id="dd9d" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Consider if each Block Window had a complete, separate copy of the logical register file, and propagation happened on write, not read. Then each instruction could use only its local registers. Register forwarding paths could exist separately for each logical register, rather than supporting full, any-register-to-any-register communication.</p><p id="6bd1" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">I can think of two interesting approaches to build this. Each logical register could have an associated bus, and each BW&#x2019;s copy would be instantiated to know which BW to take its result from. This would be efficient, and would only bottleneck when the same logical register is written to multiple times in the same cycle by different BWs. The second would be to allocate basic blocks to BWs in a specified order, and put each logical register on a special bus that captures the overwrite and not-ready semantics directly.</p><figure class="lb lc ld le fz mm fn fo paragraph-image"><figcaption class="mt bm fp fn fo mu mv bn b bo bp co">Basic blocks are allocated to BWs 0, 3, 6, 1, 4, 7, 2, 5, 8, 0, &#x2026;, in that order, to spread out demand for execution units. Signals can propagate through multiple BWs when the red lines are set, which happens when the corresponding BW will never write to that logical register, so the previous value is preserved. When a value is written, the orange-yellow line is enabled, and the BW&#x2019;s value is pushed to the bus. The blue lines enable skip connections, which might reduce latency.</figcaption></figure><p id="14c2" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">In this approach, each register communicates point-to-point, and there is no contention whatsoever, but the fixed order of BWs limits the overall depth of runahead execution.</p><h2 id="3dc1" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">2. Control Flow</h2><p id="996b" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">The saving grace of computing has in many ways been the branch predictor. If we assume the predictor is 97% accurate, which is not unreasonable, and branch instructions (both taken and untaken) occur once every 5 instructions, the predictor accurately projects a path on average 5 / 0.03 &#x2248; 167 instructions into the future. The power of an out-of-order processor is that it is able to reorder instructions as it wills within as much of this window as currently processed. In an out-of-order processor, branch instructions <em class="kc">terminate</em> dependency chains &#x2014; that is, no instruction ever depends or thereby waits on a correctly-predicted branch instruction. So too with CG-OoO, where control flow terminates basic blocks, and many successive basic blocks can evaluate in parallel as their dependencies are resolved.</p><p id="a2d8" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">No in-order approach seems to recognize how much work out-of-order hardware puts in to making control flow a manageable issue &#x2014; albeit the <em class="kc">effort</em> it spends to get that work done is well understood. This is the first junction in this story where I will state I feel the Mill is insufficiently powerful to handle the performance demands of the competition. The frequency of control flow makes getting this right so important as to undermine any approach that fails to handle it well, which makes this discussion particularly interesting.</p><p id="b9e2" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The approaches to try to extract this kind of behaviour from an in-order machine look at first blush quite limited. Branch prediction is still used to hide the instruction fetch and decode delay, and the Mill has a convincing argument that its predictor could be better than the standard approach, so that should not be a concern, and will not be detailed here. Branch delay slots, where a branch waits a number of cycles before happening, are mostly useless for correctly predicted branches, but the Mill does have a related and interesting idea with their &#x2018;phasing&#x2019; concept (albeit they sell this as increasing performance more generally, which it does not). The idea there is equivalent in nature to a branch delay slot a fraction of a cycle long, where sink instructions in the exiting block can interleave with non-sink instructions in the entered block. This &#x2018;tears&#x2019; the branch over several cycles, avoiding sparse &#x2018;warm-up&#x2019; and &#x2018;cool-down&#x2019; instructions where units go underutilized.</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="f79c" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">It should be noted that the delays in the VLIW example is illustrative of a typical dependency chain, but unusual instruction distributions could actually favour a standard VLIW.</p><p id="90c3" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The remaining 90% of the problem with control flow is of two parts.</p><p id="da32" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">2.1 Branch instructions impose ordering constraints on the program</strong></p><p id="8dbb" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Let&#x2019;s break down the first of these concerns with an example.</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="e902" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Assume purely for sake of demonstration that addition and subtraction have latency 1, whereas multiplication has latency 2, and that all machines are fully pipelined, have no resource contention, have a superscalar width of 2, and have accurate predictors. Different examples exist for cores with larger scalaraties, but are much harder to diagram.</p><p id="9317" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">A standard in-order approach struggles to extract parallelism.</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="6a58" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">An out-of-order processor can produce an optimal trace, assuming the compiler is smart enough to prioritize <code class="gh no np nq li b">c</code> even without a directly exposed pipeline.</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="6c23" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">There are two common directions for mitigating this in-order disadvantage, typically part of what is termed &#x2018;superblock scheduling&#x2019; in compilers: moving instructions to after the branch executes (&#x2018;hoist below&#x2019;), or executing them early, before the branch (&#x2018;hoist above&#x2019;). Host below allows you to overlap the critical path of the instructions in one basic block with the critical path of instructions in another, improving scheduling, but it adds a dependency on the branch at runtime. Hoist above removes a dependency on the branch, but requires simultaneous evaluation of both targets <em class="kc">even when the core has accurate predictions of the actual branch target.</em></p><pre class="lb lc ld le fz lf bt lg"></pre><p id="fb75" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Hoist-above has the additional issue of requiring disambiguation between the two halves of its computation after the fact (you need to pick which values to keep), and risks exponential blowup if you are speculating more than one branch deep. The disambiguation required in hoist-above also forces following instructions to depend on both paths of the computation, independent of whether one side is much shorter and faster than the other. Compromises with less or mixed levels of hoisting suffer a similar mix of these issues.</p><p id="3c05" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The Mill intends to tackle this issue mostly with hoist-above, mitigating the cost of these extra computations by having very cheap (sub-cycle) disambiguation instructions and a significantly wider core than its direct competitors. This is wasteful, and still doesn&#x2019;t schedule instructions efficiently.</p><p id="a9e5" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii"><em class="kc">Idea: Branch Predict and Branch Verify</em></strong></p><p id="ed9f" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><em class="kc">Edit: Tapabrata Ghosh (deepnotderp) </em><em class="kc">points to</em><em class="kc"> a paper from 2015 that invented this same technique, </em><em class="kc">Branch vanguard: decomposing branch functionality into prediction and resolution instructions</em><em class="kc">.</em></p><p id="94f2" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This issue seems to be resolvable in part, with a few key insights. The out-of-order core is able to start executing down the right path ahead of time not because it went out of order, but because it trusted its predictor. An in-order processor can do this too! Let me introduce two very unique instructions.</p><p id="8777" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii"><em class="kc">brp (Branch Predict):</em></strong><em class="kc"> Takes an address to branch to, and takes the branch if and only if the branch predictor suggests to do so. This instruction does not take a predicate as an argument.</em></p><p id="c751" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii"><em class="kc">brv (Branch Verify):</em></strong><em class="kc"> Takes a predicate, and the tag of a </em><strong class="jg ii"><em class="kc">brp</em></strong><em class="kc"> to update. If the predicate is false, branches to the other address in the </em><strong class="jg ii"><em class="kc">brp</em></strong><em class="kc"> designated by a bit in the instruction; fallthrough if down the taken path, taken if down the fallthrough path. The verify instruction is never predicted to be taken. If the verify is taken, the branch predictor is updated for the corresponding Branch Predict instruction instead.</em></p><p id="b018" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This pair may seem unintuitive at first, but it is really just a simple decomposition of parts of a branch instruction that were already there. This pair of instructions allows getting the good schedules of hoist-below without the dependencies it invokes.</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="6f6f" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Note that <code class="gh no np nq li b">brp</code> exists purely in control-flow, so like static branches it does not take a pipeline slot, and is only displayed to make the order of instructions clear.</p><p id="0774" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">There are still struggles with <code class="gh no np nq li b">brp</code>, even if one agrees that it improves the situation.</p><ul class><li id="e1aa" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb mc md me mf gi">In the case of converging control flow, where multiple branches lead to the same block, hoist-below can fail, since incoming branches will want to hoist different instruction sequences. Fortunately, unconditional converging jumps can be tackled well by hoist-above.</li><li id="d9ee" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Hoist-below duplicates code down both sides of the branch. The cost of code duplication is exponential in the depth.</li><li id="7183" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">The target branch must keep around the alternative branch target&#x2019;s registers, in case of a failed branch verification, which is linear in depth.</li><li id="f067" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">All Branch Predict targets become converging targets, including <code class="gh no np nq li b">brv</code>, which requires state to be consistent regardless of which parent you come from. <code class="gh no np nq li b">brv</code> could handle this with dedicated recovery code or hardware support, whichever works best.</li><li id="771e" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Store instructions cannot be performed speculatively without special hardware support, and load instructions still depend on them.</li></ul><p id="e37b" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The exponential cost in code duplication, and significant register pressure at higher depths, means <code class="gh no np nq li b">brp</code> should still be used fairly shallowly, maybe two deep. This is vastly less than an out-of-order processor can go, so <code class="gh no np nq li b">brp</code> is far from a be-all solution on its own.</p><p id="0028" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">2.2 Branches outside the current context are opaque to the compiler</strong></p><p id="5df0" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">A branch instruction to a function, or especially a branch instruction through a pointer, cannot generally have calculations hoisted across it. Static function calls can be inlined, which works pretty well when the cost of inlining is manageable, but those the compiler decides not to, as well as those that cannot be, are a wall to any standard static compiler.</p><p id="208b" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The Mill has some very interesting approaches here, but nothing that changes the overall cost landscape. Function call overhead on the Mill is incredibly low; this is down to some fancy optimizations such as their single-cycle bulk rename. Function calls chain cheaply and don&#x2019;t interrupt the local instruction schedule. Memory has some interesting but incomplete interactions, which will be covered in a memory section.</p><p id="fadc" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Alas, none of this changes the fact that the Mill can&#x2019;t interleave the evaluation of two called functions. The only directly mitigating factors seem to be that inlining is fairly aggressive, and indirect branches are the most difficult branches for out-of-order hardware too. Perhaps the Mill&#x2019;s faster calls and lower mispredict penalty will trade equal for this, but the world might not be so kind.</p><p id="c3ed" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">It would be nice to solve this issue, even if it is not problematic to get wrong as the section from before. I do not know how. This concludes the control flow section.</p><h2 id="6d52" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">3. Variable-latency instructions</h2><p id="cab2" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Scheduling statically for variable-latency instructions is hard. However, a convenient truth of hardware is that the efficient ways to calculate results are generally timing-agnostic with respect to their inputs. As far as I know, there are only three exceptions in a standard processor that are difficult to avoid.</p><ol class><li id="e34f" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb nl md me mf gi">Branches, which are expensive when unpredictable. Hardware handles this by scheduling for the predicted scenario and trying to to avoid mispredicts getting too slow, which works very well.</li><li id="08ff" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Division, except by a constant. Division instructions are rare enough not to strictly require efficient handling, with the Mill taking the unusual approach of just doing divides in software (utilizing fast hardware approximations to reduce the cost).</li><li id="5a34" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi"><strong class="jg ii">Memory instructions. This is unavoidable and performance critical.</strong></li></ol><p id="a9cc" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Some other, less &#x2018;standard&#x2019; instructions exist, such as transcendentals, which I will skip over.</p><p id="2bb9" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Because the other two concerns are nearly non-issues, only the third point about memory will be addressed in detail. Other potential long-latency instructions can sometimes be modelled as memory accesses. Further, since memory latency interacts with the previously delegated concerns about memory, the topic deserves a section of its own, and this section will be cut short.</p><h2 id="af74" class="kd">Memory</h2><p id="6326" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">If the previous section gave the impression that, say, control flow is a particularly tough problem, but inventive methods can give powerful and practical tools to tackle it&#x2026; good, that was the intent. In this section I want you to take that expectation and dash it against the rocks &#x2014; memory is hard<strong class="jg ii"><em class="kc">.</em></strong> Though there are prospective tools to tackle it, nothing truly looks like a solution, and it&#x2019;s not clear that the most effective-looking solutions are even practical.</p><p id="9e54" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Memory is not just an issue because it is complex &#x2014; but it is!&#x2014;; memory is an issue because of how easily it can dwarf the concerns of the rest of the system. Whereas a branch predictor might fail once every hundred and fifty instructions, burning a dozen cycles in its wake each time it does, poorly written code may miss on cache at regular intervals, and a DRAM read takes literally hundreds of cycles. One load instruction can take more time to complete than the combined cost of 500 others, just by missing cache. A single load instruction that causes a TLB miss may take vastly longer still.</p><p id="e72d" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">An inexhaustive overview of the issues involved will aid the following discussion on how different approaches tackle them.</p><ol class><li id="4b04" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb nl md me mf gi">Reordering loads and stores over each other is normally only possible when they do not alias (they refer to different parts of memory). Despite this, hardware frequently wants to start loading from a known address before other addresses that might conflict with it are known.</li><li id="f56b" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Memory accesses can fault, which normally results in an exception. This further prevents reordering of memory operations.</li><li id="e347" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Memory accesses take anywhere from a handful of cycles, commonly 3&#x2013;4 for the top-level cache, to hundreds in the worst case. It is generally impossible provide guaranteed timings needed for static scheduling. Scheduling for throughput generally requires assuming latencies will be short, and scheduling for long latencies requires mixing distant instructions and can have lower throughput since it extends critical paths.</li><li id="745b" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Whether a memory instruction will miss cache is hard to predict. Compilers seldom have any nontrivial understanding of which instructions will be slow.</li><li id="82b4" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Any given section of code might have multiple optimal schedules, depending on which instruction miss what levels of cache, if any. The prevalence of memory instructions and the small size of the top-level cache means that this risk is not safe to disregard.</li><li id="02bb" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Hardware can handle multiple cache misses simultaneously, termed <em class="kc">memory level parallelism</em>. The opportunity to do so goes up when significant cache misses occur, but extracting this parallelism requires the architecture to be able to execute operations correspondingly far ahead in the program during those cache misses.</li><li id="94a7" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">Speculating on memory can cause side channel attacks, the most famous being Spectre. These concerns will only be discussed at the end of this topic.</li></ol><h2 id="681b" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">Baseline approaches</h2><p id="52f2" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Two historical approaches to memory are useful as a baseline to compare against. The simplest approach that significantly improves the situation for in-order processors is to delay a stall on an unfinished memory load until the result is demanded by a later instruction. A load-store queue is used to check that aliasing memory accesses do not reorder improperly relative to each other, and the core stalls to resolve conflicts if necessary. In theory, this approach can even avoid stalls on register-register moves, if proper bookkeeping is done. With appropriate scheduling by the compiler, this technique allows some load latency to be hidden. In certain circumstances a load might even be resolved after branches or function calls.</p><p id="b2a4" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">There are many restrictions to this approach. A load instruction cannot be issued as soon as its address is available if it has the potential to depend on a store later in the program; the hardware semantics mean that the declared program order is canonical. The instruction that first uses (&#x2018;<em class="kc">forces</em>&#x2019;) the load is scheduled statically, but the optimal position will depend on whether the load stalls. The load consumes a register as soon as it is issued, which increases the cost of delaying the consumer of the result. A memory operation also cannot be issued speculatively in the case that it might fault. This combination of concerns means the distance between the load and the forcing of the load will normally have to be small, so only small latencies can be hidden by it.</p><p id="34d4" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><em class="kc">Runahead</em> is a much more heavyweight attempt to tackle the problem, with some popularity today, such as in NVIDIA&#x2019;s Denver architecture. Runahead directs its effort primarily to the problem of extracting memory level parallelism during long memory stalls. After a cache miss has occurred, the processor speculatively executes down the most likely instruction path, ignoring any register values that are not known (eg. the missed load) or take too long to evaluate (eg. other loads that miss cache). When the initial cache miss has resolved, this speculative work is discarded. The intent of this speculative first pass is to start loads early, bringing their values into cache. Although the instructions executed are wasted, after resuming standard execution the core is less likely to miss cache, resulting in overall higher throughput.</p><p id="ba14" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Runahead is much cheaper than a traditional out-of-order approach to speculative execution, yet can still comfortably run many hundreds of instructions ahead, through arbitrary control flow and function calls. It tackles the most pathological memory issue, a cold cache, and it can synergize with other approaches. A common extension is to use address prediction, allowing early loads even when addresses depend on register values which are unknown.</p><h2 id="a9c1" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">Mill Computing&#x2019;s approach</h2><p id="91d0" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">The Mill uses a variant of the first approach to loads, with several key advantages and &#x2014; (though the company makes no mention of it) &#x2014; several meaningful disadvantages. Keep in mind that they have also not announced any sort of runahead execution, so their approach needs to handle the entire long-tail distribution of memory stalls.</p><p id="8204" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The specific approach the Mill has changed over time. The initially advertised approach will be discussed here, and the changes they have made will be discussed in a later security section.</p><p id="eebb" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Memory reads on the Mill are split into two parts, the initial <code class="gh no np nq li b">load</code> that should be scheduled when the address is first generated, and the retire, which occurs either after a fixed number of cycles or on reaching a specific <code class="gh no np nq li b">pickup</code> instruction that references the original <code class="gh no np nq li b">load</code>. There is also a <code class="gh no np nq li b">refuse</code> should the load be unwanted. In order for loads to be scheduled early, over potentially-hazarding stores, waiting loads must check (&#x2018;snoop&#x2019;) outgoing stores. Loads are therefore semantically ordered by the location of their retire, rather than issue. The unit that handles the load and waits for retire is called the retire station. If a memory access faults, a specific &#x2018;NaR&#x2019; data value is returned, and no exception is raised.</p><p id="df4b" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The fixed-latency <code class="gh no np nq li b">load</code>, which produces its value after a fixed cycle count, is appropriate when the consumer is in a known location relative to the producer, which is common since the Mill is statically scheduled. This operation can pass through control flow, but requires all branches to accept a retiring load at the same point, and so is only really intended to be used in branchless code segments or loops. The <code class="gh no np nq li b">pickup</code>-based retire is appropriate for diverging control flow, but tags are statically allocated which raises some specific challenges for code with loops or converging control flow that will be discussed later.</p><p id="ddf8" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Being able to hoist the initial load over other memory operations makes it much easier to schedule early. A load is also allowed to cross a complete function call invocation, such that it retires only after the call is complete. If a called function uses up the limited retire stations (say, 16), load addresses from outer context frames are saved, and reissued upon return, such that the initial <code class="gh no np nq li b">load</code> acted only as a prefetch. If the called function does not exhaust the units, the retire station remains active until its natural retire.</p><p id="6371" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Some major issues are visible in this scheme, though some of them take some effort to uncover.</p><p id="3f51" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">Issue 1: Function boundaries still prevent hoisting loads</strong></p><p id="edf8" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Consider the following code:</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="a926" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Unless <code class="gh no np nq li b">f</code> is inlined, the Mill is unable to make two important transformations:</p><ol class><li id="82bd" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb nl md me mf gi">The load of <code class="gh no np nq li b">x</code> inside <code class="gh no np nq li b">g</code> must be performed before entry to <code class="gh no np nq li b">f</code>.</li><li id="9953" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">The load of <code class="gh no np nq li b">y</code> inside <code class="gh no np nq li b">f</code> cannot be performed until after entry to <code class="gh no np nq li b">f</code>.</li></ol><p id="44bc" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This means that the Mill will never get memory level parallelism from this example. If <code class="gh no np nq li b">x</code> and <code class="gh no np nq li b">y</code> both miss the cache, you are spending twice the time waiting on memory.</p><p id="0645" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Mill Computing has told me that they do have an approach that tackles this issue which they are not ready to disclose.</p><p id="1516" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">Issue 2: Loads potentially in the critical path cannot be delayed</strong></p><p id="e749" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Consider the following code:</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="3167" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Each of the four load retires are allocated to a statically-determined cycle. The two retires on the left hand side must be in different cycles, and vice-versa for the right. All loads can potentially stall. For a given retire from the left hand side, only one load of the right hand side can potentially be active during that cycle. Therefore a stall in a dereference of <code class="gh no np nq li b">x</code> will not always be able to cover a stall in a dereference of <code class="gh no np nq li b">y</code>, regardless of how the code is compiled.</p><p id="547b" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This may be illustrated by a specific example. Consider if the first load from each side happens simultaneously, and retire together, and then the second load from each side happens simultaneously, and retire together. If the first load on the left hand side, and the second load from the right hand side misses, those misses cannot be overlapped, despite their proximity in the source code and the availability of the address.</p><p id="e128" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This issue has many forms, not just cascaded loads. Let <code class="gh no np nq li b">M</code> represent any expensive computation.</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="68cd" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">If neither load misses, the two computations should mostly overlap. If both loads miss, the two computations should not overlap. No static schedule on the Mill can work for both cases.</p><p id="6edb" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">Issue 3: Converging dataflow</strong></p><p id="47de" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Consider the following code:</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="288d" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The dereference of <code class="gh no np nq li b">x</code> would like to be performed in parallel to the evaluation of <code class="gh no np nq li b">M(y)</code>. However, only one side of the <code class="gh no np nq li b">if</code> performs a load. On the Mill, unifying these branches requires forcing the load, since its value must be available after the branches converge.</p><p id="18b2" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">Issue 4: It interacts badly with loop pipelining</strong></p><p id="1fee" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Loop pipelining is the structuring of a loop to operate over multiple sequential steps of a different iterations of a loop body. Each iteration of the original loop is split across multiple iterations of the pipelined loop, allowing the pipelined loop to operate with the latency of a single <em class="kc">stage</em> of the original loop, but the same per-iteration throughput.</p><p id="5562" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The latency-based <code class="gh no np nq li b">load</code> retire is intended for this purpose. This fails in two ways. First, and particularly important, the latency of the <code class="gh no np nq li b">load</code> is unable to change over the iterations of the loop. Consider the diagram, showing loop iterations phased over multiple cycles.</p><pre class="lb lc ld le fz lf bt lg"></pre><p id="3b30" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">When the Mill schedules like the first example, it is unable to cover very long misses with its loads. When the Mill schedules like the second example, if the loop ended up with few iterations and the load did not miss cache, many cycles would be wasted waiting on a load that had long been available. An out-of-order machine starts off like the first example in early iterations, and transposes into the second example when a cache miss happens, or over many iterations of the loop if not decode limited.</p><p id="cffd" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Secondly, any control flow internal to the loop will still prevent a latency-based <code class="gh no np nq li b">load</code>. The <code class="gh no np nq li b">pickup</code> instruction will have to be used in this case, but it cannot be pipelined over more than a full iteration of the loop because the tags used to force the load are given statically.</p><h2 id="7d0d" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">Mill Computing&#x2019;s approach, cont.</h2><p id="8178" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Mill Computing advertise their approach to memory accesses as roughly competitive to out-of-order hardware. This has been demonstrated to not be the case; not in the small sense like for control flow, where small modifications adjusted things back onto the right path, but in reaching, seemingly absolutist terms. As far as I can tell, the Mill&#x2019;s approach to memory simply does not seem to come close to fixing memory&#x2019;s performance gap between in-order and out-of-order hardware.</p><h2 id="38c7" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">Ideas for a better load</h2><p id="e9d1" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">At this point you should have a healthy fear of memory accesses. I will offer four angles to tackle this, but, as previously warned, no approach solves the problem, and some approaches may be expensive or infeasible to implement.</p><p id="2846" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">Idea 1: Prodigy-Mill hybrid approach</strong></p><p id="4da0" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The Tachyum Prodigy claims very impressive numbers from their simulations; a 4.0 GHz Prodigy is purportedly comparable to a 3.5 GHz Xeon. Their primary disclosed strategy for reducing long-tail memory latency is an unspecified variant of runahead. It is not clear what other techniques were used, but they report a degree of success, outperforming significantly an Itanium core on data cache stall counts.</p><figure class="lb lc ld le fz mm fn fo paragraph-image"><figcaption class="mt bm fp fn fo mu mv bn b bo bp co">source: https://www.hotchips.org/hc30/2conf/2.09_Tachyum_Tachyum_Hotchips_2018.pdf</figcaption></figure><p id="4b07" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Runahead is a very widely applicable technique, and may be responsible for much of the difference between these approaches, especially as the Itanium&#x2019;s load instructions were not themselves entirely na&#xEF;ve. Runahead should be possible to implement on a Mill-style CPU, which makes it a decent candidate for inclusion.</p><p id="0534" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Mill Computing have told me they have considered the idea and found that unfortunately it did not expose significant opportunities. This contradicts what I&#x2019;ve read in the literature, so I consider this an interesting idea to follow up on when it is easier to do so.</p><p id="a93c" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">Idea 2: Restricted Asynchronous Dataflow</strong></p><p id="16d7" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">One subset of concerns that seems possible to tackle independently is related to chains of multiple loads. This is very common in part to do with the commonly hierarchical structure of objects, where access to data may require chained dereferences. Dereferences like <code class="gh no np nq li b">a-&gt;b-&gt;c</code> or <code class="gh no np nq li b">a[i][j]</code> use only a small subset of operations:</p><ul class><li id="f331" class="lx ly ih jg b jh ji jl jm jp lz jt ma jx mb kb mc md me mf gi">Memory loads,</li><li id="1dd1" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Pointer addition with registers or small constants,</li><li id="3331" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb mc md me mf gi">Multiplication by small, often power-of-2 constants.</li></ul><p id="03cf" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The arithmetic here is much simpler than even the most basic arithmetic pipeline. Additionally, loads always have a significant latency; 3 or 4 cycles for top-level cache is common. These make it sound feasible for this case to be handled with dedicated, overprovisioned hardware.</p><p id="1ce3" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Consider if every retire station output to a specifically-allocated chain of asynchronous ALUs allowing the given set of operations, and that those ALUs were able to be prepared by the main core during the unit&#x2019;s minimum load latency. Further, allow those ALUs to loop back into the load unit, buffering a chained load, and let this operation happen recursively up to a hardware-defined limit. As an optional extension to the idea, consider allowing the retire station to share any of its produced values with other unit&#x2019;s ALUs. That allows operations like <code class="gh no np nq li b">a-&gt;b-&gt;c + a-&gt;b-&gt;d</code> to happen fully asynchronously.</p><figure class="lb lc ld le fz mm fn fo paragraph-image"><figcaption class="mt bm fp fn fo mu mv bn b bo bp co">The path back to the address is for chained loads, and latency-critical. The dotted path is for communication between load units, requires some kind of crossbar, and is unlikely to be latency critical. The ALUs are asynchronous and buffer their sideloaded inputs. Buffering in the ALUs and output register is designed to handle multiply-dereferenced values.</figcaption></figure><p id="268e" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The arithmetic capabilities of this design are naturally limited, and even with the optional inter-unit extension the communication between units is very restricted. As a design for a processor, this would be hopeless. However, it seems plausible that that this could be a realizable concept for the restricted cases given, which opens the door for more asynchronous memory-level parallelism without fully out-of-order hardware.</p><p id="ddfc" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Two design decisions not discussed are how to enforce memory ordering with potentially-conflicting stores, and how the crossbar is controlled.</p><p id="e608" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">Idea 3: Source-agnostic argument pickups</strong></p><p id="76eb" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Likely the first thing stopping further delay of a <code class="gh no np nq li b">pickup</code> instruction is its inability to handle function calls or converging control flow in the general case.</p><p id="7bdd" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The first baseline approach, performing <code class="gh no np nq li b">pickup</code> implicitly on first use, avoids this problem but means the only known serialization point is the initial <code class="gh no np nq li b">load</code>. A simple hybrid approach is possible. A <code class="gh no np nq li b">preload</code> instruction replaces the current <code class="gh no np nq li b">load</code> and produces a tag that resides on the belt, referring to a retire unit in a <code class="gh no np nq li b">prefetch</code> state. A <code class="gh no np nq li b">load</code> instruction takes a tag to a <code class="gh no np nq li b">preload</code> state retire unit and changes it into a <code class="gh no np nq li b">load</code> state, which is the same as <code class="gh no np nq li b">preload</code> except that the hardware guarantees order of <code class="gh no np nq li b">load</code>s is conserved. A <code class="gh no np nq li b">pickup</code> instruction takes <em class="kc">any</em> belt value; if it is a value, that value is left unchanged, if it is a tag then the corresponding load is forced and the tag is replaced <em class="kc">in place</em> with the value.</p><p id="43b7" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">If functions must <code class="gh no np nq li b">pickup</code> all of their arguments before use (with instructions to make that space-efficient), or have a way to signal to the caller which instructions will be picked up, then loads can cross function boundaries. Because the tags reside on the belt at all times, and <code class="gh no np nq li b">pickup</code> is idempotent (you don&#x2019;t need to know if the value requires <code class="gh no np nq li b">pickup</code>), they can handle more arbitrary control flow and pipelining than the standard approach.</p><p id="3366" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi"><strong class="jg ii">Idea 4: Standard prefetch</strong></p><p id="b11d" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">One of the issues mentioned before was around long-latency instructions in pipelined loops. The solution here is surprisingly simple. The paper Software Prefetching for Indirect Memory Accesses shows how to use prefetch instructions for pipelinable loops. This should be considered mandatory for in-order hardware.</p><p id="648c" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">A major concern with prefetch instructions is that many prefetches are incorrect or unnecessary, wasting hardware bandwidth. For prefetches that conflict with automatic hardware prefetching, compiler heuristics should suffice. Other prefetches require more finesse. Prefetching 32 loads ahead in a loop is effective if the loop will last 32 load instructions more, but otherwise the prefetch is wasted memory bandwidth. Hardware heuristics for which prefetches are useful, including perhaps a prefetch warmup phase for loops, is an approach that would follow historic trends. Another possibility is a conditional prefetch instruction, allowing efficient suppression of prefetches that are known to go off the end of a loop.</p><h2 id="e66e" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">Security</h2><p id="82d8" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Computers are systematically vulnerable to side-channel attacks. For example, an operation may take more power with some inputs than others; therefore information about the value is learnt by looking at power usage. The most common and dangerous attacks are timing attacks. Control flow is one of the largest contributors. The largest, memory, is the topic of this section.</p><p id="1f96" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">Whenever an address <code class="gh no np nq li b">a</code> is used to access memory, the state of the cache may be changed in a way that allows side-channel attacks to discover <code class="gh no np nq li b">a</code>. Therefore all values used as addresses should be considered leaked.</p><p id="2b91" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">The typical response to this has been dismissal &#x2014; <em class="kc">deal with it</em>&#x2014;because side channel attacks are incredibly difficult to mitigate or avoid, and secure keys and encryption could generally manually circumvent these issues with careful coding. Spectre is a particular instantiation of this exploit that can read arbitrary memory from a process in spite of these safeguards, which is why it is considered such a big deal.</p><p id="cbf3" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">A twice-indirect memory access of the form <code class="gh no np nq li b">**a</code> leaks <code class="gh no np nq li b">*a</code>. It is common for <code class="gh no np nq li b">a</code> to be untrusted and restricted to a given range of allowed values. However, if the values to be accessed are guarded only by control flow, speculative execution may still start a load of <code class="gh no np nq li b">*a</code> early, leaking data chosen by an adversary.</p><p id="aaaf" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This is a major problem, invalidating almost all of the approaches mentioned so far in their na&#xEF;ve incarnations. This affects every out-of-order processor I know of, and the mitigations for it are largely incomplete and hacky. Since CG-OoO is just an out-of-order processor from a memory perspective, that too is vulnerable.</p><p id="7aa4" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">More surprisingly, the Mill&#x2019;s approach is also susceptible to this. Their <code class="gh no np nq li b">load</code> instructions are designed to be hoisted before control flow, and efficient compilation exposes the same side channel as seen in out-of-order processors. Mill Computing published a response to the discovery, claiming that &#x201C;the Mill architecture is fundamentally immune to Spectre-like vulnerabilities&#x201D; but instead that their vulnerability to Spectre was &#x201C;a software bug in the Mill tool chain&#x201D;. For the first time known to me, the conditional load instructions, <code class="gh no np nq li b">loadtr</code> and <code class="gh no np nq li b">loadfl</code>, are introduced, which allow for non-speculative condition checking.</p><p id="109f" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This response is concerning. Ultimately, no manufacturer of out-of-order cores has responded to Spectre by abandoning speculation. Early mitigations did so at a heavy performance penalty; future processors will solve the hardest issues in hardware. It seems that either you solve this problem in hardware or you become uncompetitive; the Mill seems to be walking the latter path.</p><p id="3743" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">There are several approaches that hardware has which seem promising in avoiding Spectre. For instance, one can attempt to make loads delay writes to cache, allowing side-effect free speculation recovery. One can also focus specifically on the known exploitable variants, and prevent only that subset of speculation that leaks attacker-chosen data, such as by preventing the value of loads to be used speculatively, even if the instruction can be issued speculatively.</p><p id="a9b3" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">However, regardless of whether a mitigation exists, fast memory access is so vital to competitive performance that flushing state on context-switch would be a still be a better compromise than avoiding heavy speculation. This is an issue that must be prioritized to a major degree.</p><h2 id="201a" class="kd">Concluding Remarks</h2><p id="9753" class="pw-post-body-paragraph je jf ih jg b jh lr jj jk jl ls jn jo jp lt jr js jt lu jv jw jx lv jz ka kb ia gi">Though this article has ended on a negative note, I do not want that to be the main take-away from this post. Rather, consider that the space of possibilities that is available to us is vastly larger than the space of things that has been tried. These architectures might not be perfect, but they&#x2019;re making real steps towards solving difficult problems. I have given my own creative ideas in this post, but by no means do CG-OoO, the Mill, and my ideas cover every possible choice available.</p><p id="35d9" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">If there is some more general thing to be taken from this post, perhaps the following would make a good summary.</p><h2 id="b89f" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">A. Throughput</h2><ol class><li id="b2a0" class="lx ly ih jg b jh lr jl ls jp nr jt ns jx nt kb nl md me mf gi">The architecture must be able to route instructions efficiently and with minimal latency between a large number of functional units.</li><li id="4b54" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">The architecture should be designed to handle decode and dispatch in significant excess of the available arithmetic ILP.</li></ol><h2 id="a3ca" class="lh ke ih bn kf mw mx my kj mz na nb kn jp nc nd kr jt ne nf kv jx ng nh kz ni gi">B. Dependencies and ILP extraction</h2><ol class><li id="fda7" class="lx ly ih jg b jh lr jl ls jp nr jt ns jx nt kb nl md me mf gi">The architecture must avoid creating false dependencies of any kind.</li><li id="1fb2" class="lx ly ih jg b jh mg jl mh jp mi jt mj jx mk kb nl md me mf gi">The architecture should have a wide receptive field over the source-level program in order to see the full breadth of executable instructions.</li></ol><p id="8ecd" class="pw-post-body-paragraph je jf ih jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb ia gi">This is a big ask, but both CG-OoO and the Mill make good steps towards them, and the future, though mysterious and uncertain, holds a good deal of promise.</p></div></div></section></div></div></article></div></body></html>